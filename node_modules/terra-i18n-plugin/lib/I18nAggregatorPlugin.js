'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supportedLocales = void 0;

function generateTranslationFile(language, messages) {
  return 'import { addLocaleData } from \'react-intl\';\nimport localeData from \'react-intl/locale-data/' + language.split('-')[0] + '\';\n\naddLocaleData(localeData);\n\nconst messages = ' + JSON.stringify(messages, null, 2) + ';\nconst areTranslationsLoaded = true;\nconst locale = \'' + language + '\';\nexport {\n  areTranslationsLoaded,\n  locale,\n  messages\n};';
}

function getDirectories(srcPath, inputFileSystem) {
  return inputFileSystem.readdirSync(srcPath).filter(function (file) {
    return inputFileSystem.statSync(_path2.default.join(srcPath, file)).isDirectory();
  });
}

function readTranslations(languageMessages, currentDirectory, inputFileSystem) {
  // Check the directory for translations
  var translationsDirectory = _path2.default.resolve(currentDirectory, 'translations');
  try {
    // Check if the directory exists by attempting to read from it
    inputFileSystem.readdirSync(translationsDirectory);
    // Check the directory for each translation file
    supportedLocales.forEach(function (language) {
      var translationFile = _path2.default.resolve(translationsDirectory, language + '.json');
      try {
        _extends(languageMessages[language], JSON.parse(inputFileSystem.readFileSync(translationFile, 'utf8')));
      } catch (e) {
        // eslint-disable-next-line no-console
        console.warn('Translation file ' + language + '.json not found for ' + translationsDirectory);
      }
    });
  } catch (e) {
    // not outputting anything here as the catching of the directory not existing is not an error in this case
  }
}

function aggregateDirectory(languageMessages, currentDirectory, router, inputFileSystem) {
  readTranslations(languageMessages, currentDirectory, inputFileSystem);
  // Check the directory's router for translation files
  var modulePath = _path2.default.resolve(currentDirectory, router);
  try {
    getDirectories(modulePath, inputFileSystem).forEach(function (module) {
      aggregateDirectory(languageMessages, _path2.default.resolve(modulePath, module), router, inputFileSystem);
    });
  } catch (e) {
    // not outputting anything here as the catching of the directories not existing is not an error in this case
  }
}

function aggregateTranslationMessages(options, inputFileSystem) {
  if (!options.baseDirectory) {
    throw new Error('Please included the base directory path in the plugin options.');
  }

  if (!options.supportedLocales) {
    throw new Error('Please included the supported locales in the plugin options.');
  }

  supportedLocales = options.supportedLocales;

  var languageMessages = {};
  supportedLocales.forEach(function (language) {
    languageMessages[language] = {};
  });

  // Read translations directly from specific paths
  if (options.translationsDirectories) {
    options.translationsDirectories.forEach(function (dir) {
      return readTranslations(languageMessages, _path2.default.resolve(options.baseDirectory, dir), inputFileSystem);
    });
  }
  // Set translationsDirectoryRouters to node_modules if not specified
  var translationsDirectoryRouters = options.translationsDirectoryRouters || [];
  translationsDirectoryRouters.push('node_modules');
  // Search and aggregate translation messages under each router
  translationsDirectoryRouters.forEach(function (router) {
    return aggregateDirectory(languageMessages, options.baseDirectory, router, inputFileSystem);
  });
  return languageMessages;
}

function aggregateTranslations(options, compiler) {
  compiler.plugin('after-environment', function () {
    var inputFileSystem = options.inputFileSystem;
    if (!inputFileSystem) {
      inputFileSystem = compiler.inputFileSystem;
    }

    // Aggregate translation messages for the directory
    var languageMessages = aggregateTranslationMessages(options, inputFileSystem);
    var directoryPath = _path2.default.resolve(options.baseDirectory, 'aggregated-translations');
    var outputFileSystem = options.outputFileSystem;

    // Create the aggregated-translations directory
    if (outputFileSystem) {
      outputFileSystem.mkdirpSync(directoryPath);
    } else {
      outputFileSystem = _fs2.default;
      if (!outputFileSystem.existsSync(directoryPath)) {
        outputFileSystem.mkdirSync(directoryPath);
      }
    }

    // Create a file for each language for the aggregated messages
    supportedLocales.forEach(function (language) {
      if (language in languageMessages) {
        outputFileSystem.writeFileSync(_path2.default.resolve(directoryPath, language + '.js'), generateTranslationFile(language, languageMessages[language]));
      } else {
        throw new Error('Translation file found for ' + language + '.json, but translations were not loaded correctly. Please check that your translated modules were installed correctly.');
      }
    });
  });
}

module.exports = function (options) {
  var updatedOptions = options;
  if (updatedOptions instanceof Array) {
    updatedOptions = {
      include: updatedOptions
    };
  }

  if (!Array.isArray(updatedOptions.include)) {
    updatedOptions.include = [updatedOptions.include];
  }

  return {
    apply: aggregateTranslations.bind(undefined, updatedOptions)
  };
};